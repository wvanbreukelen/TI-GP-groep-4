#pragma config(Sensor, S1,     CSensor,  sensorColorNxtRED)
#pragma config(Sensor, S4,     BWSensor,       sensorLightActive)
#pragma config(Motor,  motorA,          MotorLeft,     tmotorNXT, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorB,          MotorRight,    tmotorNXT, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
int BWBlack = 35;
int BWWhite = 65;

int CBlack = 22;
int CWhite = 63;

float Kp = 0.40;
float Tp = 25;

float errorAmount (int inputValue, bool isBWSensor)
{
	if (isBWSensor) //We return our input minus the average of their black and white values to calculate the amount of deviance.
	{
		return (inputValue - ((BWWhite + BWBlack) / 2)) / ((BWWhite - BWBlack) / 2); //returns a float between -1 and 1
	}
	else
	{
		return inputValue - ((CWhite + CBlack) / 2) / ((CWhite - CBlack) / 2);
	}
}
task main()
{
	while(1)
	{
		float leftError = errorAmount(SensorValue[BWSensor], true);
		float rightError = errorAmount(SensorValue[CSensor], false);
		if (leftError < rightError)//right error being bigger means more whitespace to the right, so steer to the left.
		{
			float Turn = Kp * leftError;
			motor[motorB] = Tp - Turn;
			motor[motorC] = Tp + Turn;
		}
		else if (leftError > rightError) //left error being bigger means there is more whitespace to the left, so we must adjust to the right.
		{
			float Turn = Kp * rightError;
			motor[motorB] = Tp + Turn;
			motor[motorC] = Tp - Turn;
		}
		else //Else, leftError == rightError
		{
				motor[motorB] = Tp;
				motor[motorC] = Tp;
		}
	}
}
